use group::ff::Field;
use halo2_proofs::plonk::*;
use halo2_proofs::poly::Rotation;
use std::marker::PhantomData;
use halo2_proofs::circuit::*;
use halo2_proofs::{
    arithmetic::FieldExt,
    circuit::{AssignedCell, Chip, Layouter},
    plonk::{Advice, Column, Error, Fixed, Instance},
};


trait ArithmeticInstructions<F: FieldExt> {
    /// Variable representing a number.
    type Num;

    fn raw_add<FM>(
        &self,
        layouter: &mut impl Layouter<F>,
        f: FM,
    ) -> Result<(Cell, Cell, Cell), Error>
    where
        FM: FnMut() -> Value<(Assigned<F>, Assigned<F>, Assigned<F>)>;


    fn raw_multiply<FM>(
            &self,
            layouter: &mut impl Layouter<F>,
            f: FM,
    ) -> Result<(Cell, Cell, Cell), Error>
    where
        FM: FnMut() -> Value<(Assigned<F>, Assigned<F>, Assigned<F>)>;

    /// Loads a number into the circuit as a private input.
    fn load_private(&self, layouter: impl Layouter<F>, a: Cell) -> Result<Cell, Error>;

    /// Loads a number into the circuit as a fixed constant.
    fn load_constant(&self, layouter: impl Layouter<F>, constant: F) -> Result<Cell, Error>;

    // ensure two wire values are same
    fn copy(&self, layouter: impl Layouter<F>, a: Cell, b: Cell) -> Result<(), Error>;


    // /// Returns `c = a * b`.
    // fn mul(
    //     &self,
    //     layouter: impl Layouter<F>,
    //     a: Self::Num,
    //     b: Self::Num,
    // ) -> Result<Self::Num, Error>;

    // fn add(
    //     &self,
    //     layouter: impl Layouter<F>,
    //     a: Self::Num,
    //     b: Self::Num,
    // )-> Result<Self::Num, Error>;

    /// Exposes a number as a public input to the circuit.
    fn expose_public(
        &self,
        layouter: impl Layouter<F>,
        cell: Cell,
        row: usize,
    ) -> Result<(), Error>;
}
// ANCHOR_END: instructions

// ANCHOR: chip-config
/// Chip state is stored in a config struct. This is generated by the chip
/// during configuration, and then stored inside the chip.
#[derive(Clone, Debug)]
struct ArithmeticConfig {
    /// For this chip, we will use two advice columns to implement our instructions.
    /// These are also the columns through which we communicate with other parts of
    /// the circuit.
    l: Column<Advice>,
    r: Column<Advice>,
    o: Column<Advice>,

    // Fixed columns
    s_l: Column<Fixed>,
    s_r: Column<Fixed>,
    s_m: Column<Fixed>,
    s_o: Column<Fixed>,
    s_c: Column<Fixed>,

    // Public inputs
    PI: Column<Instance>,
}

struct ArithmeticChip<F: FieldExt> {
    config: ArithmeticConfig,
    _marker: PhantomData<F>,
}
impl<F: FieldExt> ArithmeticChip<F> {
    fn construct(config: ArithmeticConfig) -> Self {
        Self {
            config,
            _marker: PhantomData,
        }
    }
}
// ANCHOR: chip-impl
impl<F: FieldExt> Chip<F> for ArithmeticChip<F> {
    type Config = ArithmeticConfig;
    type Loaded = ();

    fn config(&self) -> &Self::Config {
        &self.config
    }

    fn loaded(&self) -> &Self::Loaded {
        &()
    }
}
// ANCHOR_END: chip-impl

struct Number<F: FieldExt>(AssignedCell<F, F>);

impl<F: FieldExt> ArithmeticInstructions<F> for ArithmeticChip<F> {
    type Num = Number<F>;

    fn raw_add<FM>(
        &self,
        layouter: &mut impl Layouter<F>,
        mut f: FM,
    ) -> Result<(Cell, Cell, Cell), Error>
    where
        FM: FnMut() -> Value<(Assigned<F>, Assigned<F>, Assigned<F>)> {
            layouter.assign_region(
                || "add",
                |mut region| {
                    let mut values = None;
                    let lhs = region.assign_advice(
                        || "lhs",
                        self.config.l,
                        0,
                        || {
                            values = Some(f());
                            values.unwrap().map(|v| v.0)
                        },
                    )?;
                    let rhs = region.assign_advice(
                        || "rhs",
                        self.config.r,
                        0,
                        || values.unwrap().map(|v| v.1),
                    )?;
    
                    let out = region.assign_advice(
                        || "out",
                        self.config.o,
                        0,
                        || values.unwrap().map(|v| v.2),
                    )?;
    
                    region.assign_fixed(|| "l", self.config.s_l, 0, || Value::known(F::one()))?;
                    region.assign_fixed(|| "r", self.config.s_r, 0, || Value::known(F::one()))?;
                    region.assign_fixed(|| "o", self.config.s_o, 0, || Value::known(F::one()))?;
    
                    Ok((lhs.cell(), rhs.cell(), out.cell()))
                },
            )
    }
    
    fn raw_multiply<FM>(
        &self,
        layouter: &mut impl Layouter<F>,
        mut f: FM,
    ) -> Result<(Cell, Cell, Cell), Error>
    where
        FM: FnMut() -> Value<(Assigned<F>, Assigned<F>, Assigned<F>)>,
    {
        layouter.assign_region(
            || "mul",
            |mut region| {
                let mut values = None;
                let lhs = region.assign_advice(
                    || "lhs",
                    self.config.l,
                    0,
                    || {
                        values = Some(f());
                        values.unwrap().map(|v| v.0)
                    },
                )?;
                let rhs = region.assign_advice(
                    || "rhs",
                    self.config.r,
                    0,
                    || values.unwrap().map(|v| v.1),
                )?;

                let out = region.assign_advice(
                    || "out",
                    self.config.o,
                    0,
                    || values.unwrap().map(|v| v.2),
                )?;

                region.assign_fixed(|| "m", self.config.s_m, 0, || Value::known(F::one()))?;
                region.assign_fixed(|| "o", self.config.s_o, 0, || Value::known(F::one()))?;

                Ok((lhs.cell(), rhs.cell(), out.cell()))
            },
        )
    }
    fn load_private(&self, _layouter: impl Layouter<F>, a: Cell) -> Result<Cell, Error> {
        todo!()
    }
    
    fn load_constant(&self, layouter: impl Layouter<F>, constant: F) -> Result<Cell, Error> {
        todo!()
    }
    
    fn copy(&self, mut layouter: impl Layouter<F>, a: Cell, b: Cell) -> Result<(), Error> {
        layouter.assign_region(|| "copy",
            |mut region| {
                region.constrain_equal(a, b)
    })
}
    
    fn expose_public(
        &self,
        mut layouter: impl Layouter<F>,
        cell: Cell,
        row: usize,
    ) -> Result<(), Error> {
        let config = self.config();

        layouter.constrain_instance(cell, config.PI, row)
    }
}
// ANCHOR_END: instructions-impl

#[derive(Default)]
struct ArithmeticCircuit<F: FieldExt> {
    constant: F,
    x: Value<F>,
    y: Value<F>,
}

impl<F: FieldExt> Circuit<F> for ArithmeticCircuit<F> {
    // Since we are using a single chip for everything, we can just reuse its config.
    type Config = ArithmeticConfig;
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&self) -> Self {
        Self::default()
    }

    fn configure(meta: &mut ConstraintSystem<F>) -> Self::Config {
        let l: Column<Advice> = meta.advice_column();
        let r: Column<Advice> = meta.advice_column();
        let o: Column<Advice> = meta.advice_column();

        meta.enable_equality(l);
        meta.enable_equality(r);
        meta.enable_equality(o);

        let s_l: Column<Fixed> = meta.fixed_column();
        let s_r: Column<Fixed> = meta.fixed_column();
        let s_m: Column<Fixed> = meta.fixed_column();
        let s_o: Column<Fixed> = meta.fixed_column();
        let s_c: Column<Fixed> = meta.fixed_column();
        #[allow(non_snake_case)]
        let PI: Column<Instance> = meta.instance_column();
        meta.enable_equality(PI);

        meta.create_gate("mini_plonk", |meta| {
            let l = meta.query_advice(l, Rotation::cur());
            let r = meta.query_advice(r, Rotation::cur());
            let o = meta.query_advice(o, Rotation::cur());

            let s_l  = meta.query_fixed(s_l, Rotation::cur());
            let s_r  = meta.query_fixed(s_r, Rotation::cur());
            let s_o  = meta.query_fixed(s_o, Rotation::cur());
            let s_m  = meta.query_fixed(s_m, Rotation::cur());
            let s_c  = meta.query_fixed(s_c, Rotation::cur());

            vec![l.clone()*s_l + r.clone() * s_r + l*r*s_m + (o*s_o* (-F::one())) + s_c]
        });
        

        ArithmeticConfig {
            l,
            r,
            o,
            s_l,
            s_r,
            s_o,
            s_m,
            s_c,
            PI,
        }
    }


fn synthesize(
        &self,
        config: Self::Config,
        mut layouter: impl Layouter<F>,
    ) -> Result<(), Error> {
        let arith_chip = ArithmeticChip::<F>::construct(config);

        let x: Value<Assigned<F>> = self.x.into();
        let y: Value<Assigned<F>> = self.y.into();
        let _consty = Assigned::from(self.constant);

        let (a0, b0, c0) = arith_chip.raw_multiply(&mut layouter,  || x.map(|x| (x,x,x*x)))?;
       // arith_chip.copy(layouter, a0, b0)?;

        let (a1, b1, _c1) = arith_chip.raw_multiply(&mut layouter, || y.map(|y| (y,y,y*y)))?;
       // arith_chip.copy(layouter, a1, b1)?;

       //let (a1, b1, c1) = arith_chip.raw_multiply(&mut layouter, ||(|x,y| (x,y,x*y)))?;
      
        Ok(())
    }
}
    // ANCHOR_END: circuit

    fn main() {
        use halo2_proofs::{dev::MockProver, pasta::Fp};
    
        // ANCHOR: test-circuit
        // The number of rows in our circuit cannot exceed 2^k. Since our example
        // circuit is very small, we can pick a very small value here.
        let k = 4;
    
        // Prepare the private and public inputs to the circuit!
        let constant = Fp::from(7);
        let a = Fp::from(2);
        let b = Fp::from(3);
        let c = a * b;
    
        // Instantiate the circuit with the private inputs.
        let circuit = ArithmeticCircuit {
            constant,
            x: Value::known(a),
            y: Value::known(b),
        };
    
        // Arrange the public input. We expose the multiplication result in row 0
        // of the instance column, so we position it there in our public inputs.
        let public_inputs = vec![c];
        println!("public inputs: {:?}", public_inputs);
    
        // Given the correct public input, our circuit will verify.
        let prover = MockProver::run(k, &circuit, vec![public_inputs.clone()]).unwrap();
        assert_eq!(prover.verify(), Ok(()));

        // If we try some other public input, the proof will fail!
        // public_inputs[0] += Fp::one();
        // let prover = MockProver::run(k, &circuit, vec![public_inputs]).unwrap();
        // assert!(prover.verify().is_err());
        //println!("public inputs: {:?}", public_inputs[0]);
        // ANCHOR_END: test-circuit
}
